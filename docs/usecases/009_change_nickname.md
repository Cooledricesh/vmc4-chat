# Usecase 009: 닉네임 변경

**문서 번호:** UC-009
**기능명:** 닉네임 변경
**작성일:** 2025-10-19
**관련 유저플로우:** 9. 닉네임 변경 유저플로우

---

## 1. 개요

로그인한 사용자가 마이페이지에서 자신의 닉네임을 변경하는 기능입니다. 닉네임 변경 시 JWT 토큰이 재발급되며, 헤더 및 전역 UI에 즉시 반영됩니다. 과거 작성한 메시지는 이전 닉네임을 유지합니다.

---

## 2. 사전 조건

- 사용자가 로그인 상태여야 합니다 (JWT 토큰 유효).
- 마이페이지(/mypage)에 접근할 수 있어야 합니다.
- users 테이블이 정상적으로 구성되어 있어야 합니다.

---

## 3. 액터

- **주 액터:** 로그인된 사용자
- **부 액터:** Cokaotalk 백엔드 시스템, 데이터베이스, JWT 토큰 발급 시스템

---

## 4. 기본 시나리오 (정상 흐름)

### 4.1. 마이페이지 접속
1. 사용자가 헤더의 "마이페이지" 버튼을 클릭합니다.
2. 시스템이 마이페이지(/mypage)로 이동합니다.

### 4.2. 현재 닉네임 표시
3. 마이페이지에 현재 닉네임이 표시됩니다.
4. 닉네임 변경 섹션이 표시됩니다:
   - "현재 닉네임: 홍길동"
   - 새 닉네임 입력 필드
   - 저장 버튼

### 4.3. 새 닉네임 입력
5. 사용자가 새 닉네임을 입력합니다 (1-50자).
6. 시스템이 실시간으로 유효성을 검증합니다:
   - 길이 확인 (1-50자)
   - 현재 닉네임과 동일 여부 확인

### 4.4. 저장 요청
7. 사용자가 "저장" 버튼을 클릭합니다.
8. 저장 버튼이 비활성화되어 중복 제출을 방지합니다.

### 4.5. 서버 처리
9. 서버가 다음을 수행합니다:
   - JWT 토큰에서 사용자 ID 추출
   - 새 닉네임 유효성 재검증
   - users 테이블 업데이트:
     ```sql
     UPDATE users
     SET nickname = $1, updated_at = NOW()
     WHERE id = $2
     RETURNING id, email, nickname;
     ```

### 4.6. JWT 토큰 재발급
10. 서버가 새 닉네임을 포함한 JWT 토큰을 생성합니다:
    ```json
    {
      "userId": "user-uuid",
      "email": "user@example.com",
      "nickname": "새닉네임",
      "iat": 1697712000,
      "exp": 1697798400
    }
    ```
11. HTTP-only 쿠키를 업데이트합니다.

### 4.7. 클라이언트 상태 업데이트
12. 클라이언트가 전역 상태(Zustand)의 사용자 정보를 갱신합니다.
13. 헤더의 닉네임 표시가 즉시 업데이트됩니다.
14. 마이페이지의 현재 닉네임이 갱신됩니다.

### 4.8. 성공 피드백
15. "닉네임이 변경되었습니다" 성공 메시지가 표시됩니다 (토스트 또는 인라인).
16. 입력 필드가 초기화되고 저장 버튼이 재활성화됩니다.

---

## 5. 대체 시나리오 (예외 상황)

### 5.1. 닉네임 미입력
- **조건:** 입력 필드가 비어있음
- **결과:** "닉네임을 입력해주세요" 오류 메시지
- **복구:** 사용자가 닉네임 입력 후 재시도

### 5.2. 닉네임 길이 오류
- **조건:** 1자 미만 또는 50자 초과
- **결과:**
  - 1자 미만: "닉네임은 최소 1자 이상이어야 합니다"
  - 51자 이상: 입력 차단 (maxlength=50)
- **복구:** 적절한 길이로 수정

### 5.3. 현재 닉네임과 동일
- **조건:** 새 닉네임이 현재 닉네임과 같음
- **결과:** "현재 닉네임과 동일합니다" 안내 메시지
- **복구:** 사용자가 다른 닉네임 입력

### 5.4. 미인증 사용자
- **조건:** JWT 토큰 만료 또는 없음
- **결과:**
  - HTTP 401 Unauthorized 응답
  - 로그인 페이지로 자동 리디렉션
- **복구:** 재로그인 후 마이페이지 접근

### 5.5. 네트워크 오류
- **조건:** 변경 요청 중 네트워크 끊김
- **결과:**
  - "네트워크 연결을 확인해주세요" 오류 메시지
  - 저장 버튼 재활성화
  - 입력값 유지
- **복구:** 네트워크 확인 후 재시도

### 5.6. 서버 오류
- **조건:** 데이터베이스 업데이트 실패
- **결과:**
  - HTTP 500 응답
  - "일시적인 오류가 발생했습니다" 메시지
  - 저장 버튼 재활성화
- **복구:** 잠시 후 재시도

### 5.7. 변경 중 로그아웃
- **조건:** 다른 탭/창에서 로그아웃 또는 세션 만료
- **결과:**
  - 작업 취소
  - 로그인 페이지로 리디렉션
- **복구:** 재로그인 후 재시도

---

## 6. 사후 조건

### 성공 시
- users 테이블의 nickname 필드가 업데이트됩니다.
- JWT 토큰에 새 닉네임이 포함됩니다.
- 헤더 및 마이페이지에 새 닉네임이 표시됩니다.
- 이후 작성하는 메시지에 새 닉네임이 사용됩니다.
- 과거 메시지는 이전 닉네임 유지 (메시지 테이블은 변경 없음).

### 실패 시
- users 테이블에 변경이 없습니다.
- JWT 토큰은 이전 상태 유지됩니다.
- 전역 상태는 변경되지 않습니다.
- 사용자에게 오류 메시지가 표시됩니다.

---

## 7. 비기능적 요구사항

### 7.1. 성능
- 닉네임 변경 처리 시간: 1초 이내
- 전역 상태 업데이트: 즉시

### 7.2. 보안
- 사용자 인증 필수 (JWT 토큰 검증)
- 본인만 자신의 닉네임 변경 가능
- XSS 방지 (입력값 이스케이프)

### 7.3. 데이터 일관성
- 과거 메시지는 작성 당시의 닉네임 유지
- 새 메시지부터 새 닉네임 적용
- 채팅방 참여자 목록에서는 현재 닉네임 표시

### 7.4. 사용성
- 실시간 유효성 검증
- 명확한 성공/실패 피드백
- 입력값 유지 (오류 시)

---

## 8. UI/UX 요구사항

### 8.1. 마이페이지 레이아웃
- **섹션 제목:** "닉네임 변경"
- **현재 닉네임:** "현재 닉네임: 홍길동"
- **입력 필드:** 새 닉네임 입력
- **저장 버튼:** 하단 또는 우측

### 8.2. 입력 필드
- **type:** text
- **placeholder:** "새 닉네임 (1-50자)"
- **maxlength:** 50
- **autocomplete:** off

### 8.3. 저장 버튼
- **기본 상태:** 파란색 배경, "저장"
- **비활성 상태:** 회색 배경 (현재 닉네임과 동일하거나 유효성 실패)
- **로딩 상태:** 스피너 + "저장 중..."

### 8.4. 피드백 메시지
- **성공:** 초록색 토스트 "닉네임이 변경되었습니다"
- **오류:** 빨간색 인라인 메시지 (입력 필드 하단)

### 8.5. 실시간 검증
- **길이 초과:** "닉네임은 최대 50자까지 가능합니다"
- **빈 값:** "닉네임을 입력해주세요"
- **현재 값과 동일:** "현재 닉네임과 동일합니다"

---

## 9. 데이터베이스 영향

### 업데이트되는 레코드
```sql
-- Before
{
  id: "user-uuid",
  email: "user@example.com",
  nickname: "홍길동",
  updated_at: "2025-10-19T12:00:00Z"
}

-- After
{
  id: "user-uuid",
  email: "user@example.com",
  nickname: "새닉네임",
  updated_at: "2025-10-19T12:05:00Z"
}
```

### 변경되지 않는 레코드
- messages 테이블: 기존 메시지의 user_id는 그대로, 닉네임은 표시 시점에 JOIN으로 조회
- room_participants 테이블: 변경 없음

### 인덱스 활용
- 기본 키(id): 사용자 식별

---

## 10. API 명세

### Endpoint
```
PATCH /api/users/me/nickname
```

### Request Headers
```
Authorization: Bearer <JWT_TOKEN>
```

### Request Body
```json
{
  "nickname": "새닉네임"
}
```

### Response (성공)
```json
{
  "success": true,
  "message": "닉네임이 변경되었습니다",
  "data": {
    "user": {
      "id": "user-uuid",
      "email": "user@example.com",
      "nickname": "새닉네임"
    },
    "token": "new-jwt-token-here"
  }
}
```

### Response (실패 - 유효성 검증)
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "닉네임은 1-50자 사이여야 합니다",
    "details": {
      "field": "nickname",
      "constraint": "length"
    }
  }
}
```

---

## 11. 상태 관리

### Zustand Actions
```typescript
// 전역 상태 업데이트
authStore.updateUser({ nickname: "새닉네임" });

// State
interface AuthState {
  user: {
    id: string;
    email: string;
    nickname: string;
  } | null;
  updateUser: (updates: Partial<User>) => void;
}
```

### React Query
```typescript
// 닉네임 변경 mutation
const changeNicknameMutation = useMutation({
  mutationFn: (nickname: string) =>
    apiClient.patch('/api/users/me/nickname', { nickname }),
  onSuccess: (data) => {
    authStore.updateUser({ nickname: data.user.nickname });
    queryClient.invalidateQueries(['user']);
    toast.success('닉네임이 변경되었습니다');
  },
});
```

---

## 12. 테스트 시나리오

### 12.1. 정상 케이스
- [ ] 유효한 닉네임으로 변경 성공
- [ ] JWT 토큰 재발급 확인
- [ ] 헤더에 새 닉네임 즉시 반영
- [ ] 마이페이지에 새 닉네임 표시

### 12.2. 유효성 검증
- [ ] 빈 닉네임 입력 시 오류 메시지
- [ ] 51자 이상 입력 차단
- [ ] 현재 닉네임과 동일 시 안내 메시지

### 12.3. 인증
- [ ] 비로그인 상태에서 접근 시 로그인 페이지 리디렉션
- [ ] 토큰 만료 시 재로그인 유도

### 12.4. 데이터베이스
- [ ] users 테이블의 nickname 필드 업데이트
- [ ] updated_at 타임스탬프 갱신
- [ ] 기존 메시지는 변경 없음

### 12.5. UX
- [ ] 실시간 유효성 검증
- [ ] 성공 토스트 메시지 표시
- [ ] 오류 시 입력값 유지
- [ ] 중복 제출 방지

---

## 13. 관련 문서

- [유저플로우 문서 - 9. 닉네임 변경](../userflow.md#9-닉네임-변경-유저플로우)
- [데이터베이스 - users 테이블](../database.md#1-users-테이블)
- [PRD - 마이페이지 기능](../prd.md)
- [Usecase 002 - 로그인](./002_login.md)
